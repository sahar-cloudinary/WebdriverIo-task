{"info":{"type":"runner","start":"2022-08-02T08:28:56.293Z","_duration":30001,"cid":"0-0","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"103.0.5060.134","chrome":{"chromedriverVersion":"103.0.5060.53 (a1711811edd74ff1cf2150f36ffa3b0dae40b17f-refs/branch-heads/5060@{#853})","userDataDir":"/var/folders/yr/j58lybtd30qfqw4j91dq_zs00000gq/T/.com.google.Chrome.CbSull"},"goog:chromeOptions":{"debuggerAddress":"localhost:61010"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"356121b8013f09394d639e870fd49775"},"sanitizedCapabilities":"chrome.103_0_5060_134.macosx","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"info","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"enableDirectConnect":true,"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.ts"],"exclude":[],"suites":{},"baseUrl":"http://localhost","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["html-nice",{"outputDir":"./reports/html-reports","filename":"report.html","reportTitle":"Test Report Title","LinkScreenshots":true,"showInBrowser":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":5,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["/Users/saharabureesh/Desktop/Task/test/specs/tests.test.ts"],"sessionId":"356121b8013f09394d639e870fd49775","isMultiremote":false,"instanceOptions":{"356121b8013f09394d639e870fd49775":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"info","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"enableDirectConnect":true,"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.ts"],"exclude":[],"suites":{},"baseUrl":"http://localhost","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["html-nice",{"outputDir":"./reports/html-reports","filename":"report.html","reportTitle":"Test Report Title","LinkScreenshots":true,"showInBrowser":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":5,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":0,"retries":0,"end":"2022-08-02T08:29:26.294Z"},"metrics":{"passed":3,"skipped":0,"failed":0,"duration":30001,"start":"2022-08-02T08:28:56.293Z","end":"2022-08-02T08:29:26Z"},"title":"Test Report Title","suites":[{"type":"suite:start","start":"2022-08-02T08:28:56.296Z","_duration":29941,"tests":[{"type":"test","start":"2022-08-02T08:28:56.296Z","_duration":19697,"uid":"test-00-0","cid":"0-0","title":"uplod page and log in","fullTitle":"Firs Task.uplod page and log in","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://staging.cloudinary.com/users/login"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://staging.cloudinary.com/users/login"},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#new_user_session"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#new_user_session"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1712fd85-debe-4083-ace5-f612ae02247b"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1712fd85-debe-4083-ace5-f612ae02247b","ELEMENT":"1712fd85-debe-4083-ace5-f612ae02247b"}]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1712fd85-debe-4083-ace5-f612ae02247b","ELEMENT":"1712fd85-debe-4083-ace5-f612ae02247b"}]},"result":{"value":true},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user_session_email"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user_session_email"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5327e01a-a04f-41e4-be34-f30e7e45d716"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5327e01a-a04f-41e4-be34-f30e7e45d716/clear","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5327e01a-a04f-41e4-be34-f30e7e45d716/clear","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5327e01a-a04f-41e4-be34-f30e7e45d716/value","body":{"text":"sahar.abureesh@cloudinary.com"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5327e01a-a04f-41e4-be34-f30e7e45d716/value","body":{"text":"sahar.abureesh@cloudinary.com"},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user_session_password"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user_session_password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5b98118a-1459-4ea8-b502-a4beaf589302"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5b98118a-1459-4ea8-b502-a4beaf589302/clear","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5b98118a-1459-4ea8-b502-a4beaf589302/clear","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5b98118a-1459-4ea8-b502-a4beaf589302/value","body":{"text":"Sa316257211#"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5b98118a-1459-4ea8-b502-a4beaf589302/value","body":{"text":"Sa316257211#"},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sign-in"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sign-in"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"61a413fb-810b-4bba-943a-362eec38768c"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/61a413fb-810b-4bba-943a-362eec38768c/click","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/61a413fb-810b-4bba-943a-362eec38768c/click","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"}],"retries":0,"parent":"Firs Task","state":"passed","events":[],"errorIndex":0,"end":"2022-08-02T08:29:15.993Z"},{"type":"test","start":"2022-08-02T08:29:15.995Z","_duration":6763,"uid":"test-00-1","cid":"0-0","title":"Open MediaLibrary and Click with right-click on the image ","fullTitle":"Firs Task.Open MediaLibrary and Click with right-click on the image ","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-balloon=\"Media Library\"]"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-balloon=\"Media Library\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"48da5655-8a44-41cc-9439-14374d57df87"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/48da5655-8a44-41cc-9439-14374d57df87/click","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/48da5655-8a44-41cc-9439-14374d57df87/click","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div\"}\n  (Session info: chrome=103.0.5060.134)","stacktrace":"0   chromedriver                        0x0000000102785d14 chromedriver + 3792148\n1   chromedriver                        0x000000010271c828 chromedriver + 3360808\n2   chromedriver                        0x000000010241d0b8 chromedriver + 217272\n3   chromedriver                        0x000000010244ce90 chromedriver + 413328\n4   chromedriver                        0x0000000102475a60 chromedriver + 580192\n5   chromedriver                        0x0000000102442318 chromedriver + 369432\n6   chromedriver                        0x000000010275b1e8 chromedriver + 3617256\n7   chromedriver                        0x000000010275f678 chromedriver + 3634808\n8   chromedriver                        0x0000000102763c6c chromedriver + 3652716\n9   chromedriver                        0x0000000102760110 chromedriver + 3637520\n10  chromedriver                        0x000000010273e7ac chromedriver + 3499948\n11  chromedriver                        0x0000000102777bf0 chromedriver + 3734512\n12  chromedriver                        0x0000000102777d54 chromedriver + 3734868\n13  chromedriver                        0x000000010278c558 chromedriver + 3818840\n14  libsystem_pthread.dylib             0x00000001a3e9426c _pthread_start + 148\n15  libsystem_pthread.dylib             0x00000001a3e8f08c thread_start + 8\n"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"30287285-1ce0-44e1-931b-9cf4be1b56db"}]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"30287285-1ce0-44e1-931b-9cf4be1b56db"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"type":"pointer","id":"pointer1","parameters":{"pointerType":"mouse"},"actions":[{"type":"pointerMove","origin":{"sessionId":"356121b8013f09394d639e870fd49775","error":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div\"}\n  (Session info: chrome=103.0.5060.134)","stacktrace":"0   chromedriver                        0x0000000102785d14 chromedriver + 3792148\n1   chromedriver                        0x000000010271c828 chromedriver + 3360808\n2   chromedriver                        0x000000010241d0b8 chromedriver + 217272\n3   chromedriver                        0x000000010244ce90 chromedriver + 413328\n4   chromedriver                        0x0000000102475a60 chromedriver + 580192\n5   chromedriver                        0x0000000102442318 chromedriver + 369432\n6   chromedriver                        0x000000010275b1e8 chromedriver + 3617256\n7   chromedriver                        0x000000010275f678 chromedriver + 3634808\n8   chromedriver                        0x0000000102763c6c chromedriver + 3652716\n9   chromedriver                        0x0000000102760110 chromedriver + 3637520\n10  chromedriver                        0x000000010273e7ac chromedriver + 3499948\n11  chromedriver                        0x0000000102777bf0 chromedriver + 3734512\n12  chromedriver                        0x0000000102777d54 chromedriver + 3734868\n13  chromedriver                        0x000000010278c558 chromedriver + 3818840\n14  libsystem_pthread.dylib             0x00000001a3e9426c _pthread_start + 148\n15  libsystem_pthread.dylib             0x00000001a3e8f08c thread_start + 8\n"},"selector":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"103.0.5060.134","chrome":{"chromedriverVersion":"103.0.5060.53 (a1711811edd74ff1cf2150f36ffa3b0dae40b17f-refs/branch-heads/5060@{#853})","userDataDir":"/var/folders/yr/j58lybtd30qfqw4j91dq_zs00000gq/T/.com.google.Chrome.CbSull"},"goog:chromeOptions":{"debuggerAddress":"localhost:61010"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true},"config":{"specs":["./test/specs/**/*.ts"],"suites":{},"exclude":[],"logLevel":"info","logLevels":{},"excludeDriverLogs":[],"bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["html-nice",{"outputDir":"./reports/html-reports","filename":"report.html","reportTitle":"Test Report Title","LinkScreenshots":true,"showInBrowser":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"connectionRetryTimeout":120000,"connectionRetryCount":3,"execArgv":[],"runnerEnv":{},"runner":"local","specFileRetries":0,"specFileRetriesDelay":0,"specFileRetriesDeferred":false,"reporterSyncInterval":100,"reporterSyncTimeout":5000,"cucumberFeaturesWithLineNumbers":[],"autoCompileOpts":{"autoCompile":true,"tsNodeOpts":{"transpileOnly":true,"project":"test/tsconfig.json"},"babelOpts":{}},"mochaOpts":{"timeout":60000,"ui":"bdd"},"jasmineOpts":{"defaultTimeoutInterval":10000},"cucumberOpts":{"timeout":10000},"onPrepare":[null],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"beforeFeature":[],"beforeScenario":[],"beforeStep":[],"afterStep":[],"afterScenario":[],"afterFeature":[],"baseUrl":"http://localhost","_":["run"],"$0":"/Users/saharabureesh/Desktop/Task/node_modules/.bin/wdio","config-path":"test/wdio.conf.ts","ignoredWorkerServices":[]}},"isReactElement":false,"elementId":"30287285-1ce0-44e1-931b-9cf4be1b56db","element-6066-11e4-a52e-4f735466cecf":"30287285-1ce0-44e1-931b-9cf4be1b56db"},"x":0,"y":0},{"type":"pointerDown","button":2},{"type":"pointerUp","button":2}]}]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"type":"pointer","id":"pointer1","parameters":{"pointerType":"mouse"},"actions":[{"type":"pointerMove","origin":{"sessionId":"356121b8013f09394d639e870fd49775","error":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div\"}\n  (Session info: chrome=103.0.5060.134)","stacktrace":"0   chromedriver                        0x0000000102785d14 chromedriver + 3792148\n1   chromedriver                        0x000000010271c828 chromedriver + 3360808\n2   chromedriver                        0x000000010241d0b8 chromedriver + 217272\n3   chromedriver                        0x000000010244ce90 chromedriver + 413328\n4   chromedriver                        0x0000000102475a60 chromedriver + 580192\n5   chromedriver                        0x0000000102442318 chromedriver + 369432\n6   chromedriver                        0x000000010275b1e8 chromedriver + 3617256\n7   chromedriver                        0x000000010275f678 chromedriver + 3634808\n8   chromedriver                        0x0000000102763c6c chromedriver + 3652716\n9   chromedriver                        0x0000000102760110 chromedriver + 3637520\n10  chromedriver                        0x000000010273e7ac chromedriver + 3499948\n11  chromedriver                        0x0000000102777bf0 chromedriver + 3734512\n12  chromedriver                        0x0000000102777d54 chromedriver + 3734868\n13  chromedriver                        0x000000010278c558 chromedriver + 3818840\n14  libsystem_pthread.dylib             0x00000001a3e9426c _pthread_start + 148\n15  libsystem_pthread.dylib             0x00000001a3e8f08c thread_start + 8\n"},"selector":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"103.0.5060.134","chrome":{"chromedriverVersion":"103.0.5060.53 (a1711811edd74ff1cf2150f36ffa3b0dae40b17f-refs/branch-heads/5060@{#853})","userDataDir":"/var/folders/yr/j58lybtd30qfqw4j91dq_zs00000gq/T/.com.google.Chrome.CbSull"},"goog:chromeOptions":{"debuggerAddress":"localhost:61010"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true},"config":{"specs":["./test/specs/**/*.ts"],"suites":{},"exclude":[],"logLevel":"info","logLevels":{},"excludeDriverLogs":[],"bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["html-nice",{"outputDir":"./reports/html-reports","filename":"report.html","reportTitle":"Test Report Title","LinkScreenshots":true,"showInBrowser":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"connectionRetryTimeout":120000,"connectionRetryCount":3,"execArgv":[],"runnerEnv":{},"runner":"local","specFileRetries":0,"specFileRetriesDelay":0,"specFileRetriesDeferred":false,"reporterSyncInterval":100,"reporterSyncTimeout":5000,"cucumberFeaturesWithLineNumbers":[],"autoCompileOpts":{"autoCompile":true,"tsNodeOpts":{"transpileOnly":true,"project":"test/tsconfig.json"},"babelOpts":{}},"mochaOpts":{"timeout":60000,"ui":"bdd"},"jasmineOpts":{"defaultTimeoutInterval":10000},"cucumberOpts":{"timeout":10000},"onPrepare":[null],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"beforeFeature":[],"beforeScenario":[],"beforeStep":[],"afterStep":[],"afterScenario":[],"afterFeature":[],"baseUrl":"http://localhost","_":["run"],"$0":"/Users/saharabureesh/Desktop/Task/node_modules/.bin/wdio","config-path":"test/wdio.conf.ts","ignoredWorkerServices":[]}},"isReactElement":false,"elementId":"30287285-1ce0-44e1-931b-9cf4be1b56db","element-6066-11e4-a52e-4f735466cecf":"30287285-1ce0-44e1-931b-9cf4be1b56db"},"x":0,"y":0},{"type":"pointerDown","button":2},{"type":"pointerUp","button":2}]}]},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"}],"retries":0,"parent":"Firs Task","state":"passed","events":[],"errorIndex":0,"end":"2022-08-02T08:29:22.758Z"},{"type":"test","start":"2022-08-02T08:29:22.761Z","_duration":3475,"uid":"test-00-2","cid":"0-0","title":"Choose the manage option and make sure the title is approptiate","fullTitle":"Firs Task.Choose the manage option and make sure the title is approptiate","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"action-manage-btn\"]"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"action-manage-btn\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e1cc26bf-1221-45b0-8223-d29de1c4a667"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e1cc26bf-1221-45b0-8223-d29de1c4a667/click","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e1cc26bf-1221-45b0-8223-d29de1c4a667/click","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"item-title\"]"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"item-title\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9820f3d1-8078-46f2-9b00-301364b92baa"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9820f3d1-8078-46f2-9b00-301364b92baa","ELEMENT":"9820f3d1-8078-46f2-9b00-301364b92baa"}]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9820f3d1-8078-46f2-9b00-301364b92baa","ELEMENT":"9820f3d1-8078-46f2-9b00-301364b92baa"}]},"result":{"value":true},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"}],"retries":0,"parent":"Firs Task","state":"passed","events":[],"errorIndex":0,"end":"2022-08-02T08:29:26.236Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-08-02T08:28:56.296Z","_duration":19697,"uid":"test-00-0","cid":"0-0","title":"uplod page and log in","fullTitle":"Firs Task.uplod page and log in","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://staging.cloudinary.com/users/login"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://staging.cloudinary.com/users/login"},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#new_user_session"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#new_user_session"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1712fd85-debe-4083-ace5-f612ae02247b"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1712fd85-debe-4083-ace5-f612ae02247b","ELEMENT":"1712fd85-debe-4083-ace5-f612ae02247b"}]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1712fd85-debe-4083-ace5-f612ae02247b","ELEMENT":"1712fd85-debe-4083-ace5-f612ae02247b"}]},"result":{"value":true},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user_session_email"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user_session_email"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5327e01a-a04f-41e4-be34-f30e7e45d716"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5327e01a-a04f-41e4-be34-f30e7e45d716/clear","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5327e01a-a04f-41e4-be34-f30e7e45d716/clear","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5327e01a-a04f-41e4-be34-f30e7e45d716/value","body":{"text":"sahar.abureesh@cloudinary.com"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5327e01a-a04f-41e4-be34-f30e7e45d716/value","body":{"text":"sahar.abureesh@cloudinary.com"},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user_session_password"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user_session_password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5b98118a-1459-4ea8-b502-a4beaf589302"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5b98118a-1459-4ea8-b502-a4beaf589302/clear","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5b98118a-1459-4ea8-b502-a4beaf589302/clear","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5b98118a-1459-4ea8-b502-a4beaf589302/value","body":{"text":"Sa316257211#"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5b98118a-1459-4ea8-b502-a4beaf589302/value","body":{"text":"Sa316257211#"},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sign-in"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#sign-in"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"61a413fb-810b-4bba-943a-362eec38768c"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/61a413fb-810b-4bba-943a-362eec38768c/click","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/61a413fb-810b-4bba-943a-362eec38768c/click","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"}],"retries":0,"parent":"Firs Task","state":"passed","events":[],"errorIndex":0,"end":"2022-08-02T08:29:15.993Z"},{"type":"test","start":"2022-08-02T08:29:15.995Z","_duration":6763,"uid":"test-00-1","cid":"0-0","title":"Open MediaLibrary and Click with right-click on the image ","fullTitle":"Firs Task.Open MediaLibrary and Click with right-click on the image ","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-balloon=\"Media Library\"]"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-balloon=\"Media Library\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"48da5655-8a44-41cc-9439-14374d57df87"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/48da5655-8a44-41cc-9439-14374d57df87/click","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/48da5655-8a44-41cc-9439-14374d57df87/click","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div\"}\n  (Session info: chrome=103.0.5060.134)","stacktrace":"0   chromedriver                        0x0000000102785d14 chromedriver + 3792148\n1   chromedriver                        0x000000010271c828 chromedriver + 3360808\n2   chromedriver                        0x000000010241d0b8 chromedriver + 217272\n3   chromedriver                        0x000000010244ce90 chromedriver + 413328\n4   chromedriver                        0x0000000102475a60 chromedriver + 580192\n5   chromedriver                        0x0000000102442318 chromedriver + 369432\n6   chromedriver                        0x000000010275b1e8 chromedriver + 3617256\n7   chromedriver                        0x000000010275f678 chromedriver + 3634808\n8   chromedriver                        0x0000000102763c6c chromedriver + 3652716\n9   chromedriver                        0x0000000102760110 chromedriver + 3637520\n10  chromedriver                        0x000000010273e7ac chromedriver + 3499948\n11  chromedriver                        0x0000000102777bf0 chromedriver + 3734512\n12  chromedriver                        0x0000000102777d54 chromedriver + 3734868\n13  chromedriver                        0x000000010278c558 chromedriver + 3818840\n14  libsystem_pthread.dylib             0x00000001a3e9426c _pthread_start + 148\n15  libsystem_pthread.dylib             0x00000001a3e8f08c thread_start + 8\n"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"30287285-1ce0-44e1-931b-9cf4be1b56db"}]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"30287285-1ce0-44e1-931b-9cf4be1b56db"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"type":"pointer","id":"pointer1","parameters":{"pointerType":"mouse"},"actions":[{"type":"pointerMove","origin":{"sessionId":"356121b8013f09394d639e870fd49775","error":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div\"}\n  (Session info: chrome=103.0.5060.134)","stacktrace":"0   chromedriver                        0x0000000102785d14 chromedriver + 3792148\n1   chromedriver                        0x000000010271c828 chromedriver + 3360808\n2   chromedriver                        0x000000010241d0b8 chromedriver + 217272\n3   chromedriver                        0x000000010244ce90 chromedriver + 413328\n4   chromedriver                        0x0000000102475a60 chromedriver + 580192\n5   chromedriver                        0x0000000102442318 chromedriver + 369432\n6   chromedriver                        0x000000010275b1e8 chromedriver + 3617256\n7   chromedriver                        0x000000010275f678 chromedriver + 3634808\n8   chromedriver                        0x0000000102763c6c chromedriver + 3652716\n9   chromedriver                        0x0000000102760110 chromedriver + 3637520\n10  chromedriver                        0x000000010273e7ac chromedriver + 3499948\n11  chromedriver                        0x0000000102777bf0 chromedriver + 3734512\n12  chromedriver                        0x0000000102777d54 chromedriver + 3734868\n13  chromedriver                        0x000000010278c558 chromedriver + 3818840\n14  libsystem_pthread.dylib             0x00000001a3e9426c _pthread_start + 148\n15  libsystem_pthread.dylib             0x00000001a3e8f08c thread_start + 8\n"},"selector":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"103.0.5060.134","chrome":{"chromedriverVersion":"103.0.5060.53 (a1711811edd74ff1cf2150f36ffa3b0dae40b17f-refs/branch-heads/5060@{#853})","userDataDir":"/var/folders/yr/j58lybtd30qfqw4j91dq_zs00000gq/T/.com.google.Chrome.CbSull"},"goog:chromeOptions":{"debuggerAddress":"localhost:61010"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true},"config":{"specs":["./test/specs/**/*.ts"],"suites":{},"exclude":[],"logLevel":"info","logLevels":{},"excludeDriverLogs":[],"bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["html-nice",{"outputDir":"./reports/html-reports","filename":"report.html","reportTitle":"Test Report Title","LinkScreenshots":true,"showInBrowser":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"connectionRetryTimeout":120000,"connectionRetryCount":3,"execArgv":[],"runnerEnv":{},"runner":"local","specFileRetries":0,"specFileRetriesDelay":0,"specFileRetriesDeferred":false,"reporterSyncInterval":100,"reporterSyncTimeout":5000,"cucumberFeaturesWithLineNumbers":[],"autoCompileOpts":{"autoCompile":true,"tsNodeOpts":{"transpileOnly":true,"project":"test/tsconfig.json"},"babelOpts":{}},"mochaOpts":{"timeout":60000,"ui":"bdd"},"jasmineOpts":{"defaultTimeoutInterval":10000},"cucumberOpts":{"timeout":10000},"onPrepare":[null],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"beforeFeature":[],"beforeScenario":[],"beforeStep":[],"afterStep":[],"afterScenario":[],"afterFeature":[],"baseUrl":"http://localhost","_":["run"],"$0":"/Users/saharabureesh/Desktop/Task/node_modules/.bin/wdio","config-path":"test/wdio.conf.ts","ignoredWorkerServices":[]}},"isReactElement":false,"elementId":"30287285-1ce0-44e1-931b-9cf4be1b56db","element-6066-11e4-a52e-4f735466cecf":"30287285-1ce0-44e1-931b-9cf4be1b56db"},"x":0,"y":0},{"type":"pointerDown","button":2},{"type":"pointerUp","button":2}]}]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"type":"pointer","id":"pointer1","parameters":{"pointerType":"mouse"},"actions":[{"type":"pointerMove","origin":{"sessionId":"356121b8013f09394d639e870fd49775","error":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div\"}\n  (Session info: chrome=103.0.5060.134)","stacktrace":"0   chromedriver                        0x0000000102785d14 chromedriver + 3792148\n1   chromedriver                        0x000000010271c828 chromedriver + 3360808\n2   chromedriver                        0x000000010241d0b8 chromedriver + 217272\n3   chromedriver                        0x000000010244ce90 chromedriver + 413328\n4   chromedriver                        0x0000000102475a60 chromedriver + 580192\n5   chromedriver                        0x0000000102442318 chromedriver + 369432\n6   chromedriver                        0x000000010275b1e8 chromedriver + 3617256\n7   chromedriver                        0x000000010275f678 chromedriver + 3634808\n8   chromedriver                        0x0000000102763c6c chromedriver + 3652716\n9   chromedriver                        0x0000000102760110 chromedriver + 3637520\n10  chromedriver                        0x000000010273e7ac chromedriver + 3499948\n11  chromedriver                        0x0000000102777bf0 chromedriver + 3734512\n12  chromedriver                        0x0000000102777d54 chromedriver + 3734868\n13  chromedriver                        0x000000010278c558 chromedriver + 3818840\n14  libsystem_pthread.dylib             0x00000001a3e9426c _pthread_start + 148\n15  libsystem_pthread.dylib             0x00000001a3e8f08c thread_start + 8\n"},"selector":"//*[@id=\"main-content-wrapper\"]/div/div[2]/div/div/div[1]/div/div/div[8]/article/div[2]/div/div/div","parent":{"capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"103.0.5060.134","chrome":{"chromedriverVersion":"103.0.5060.53 (a1711811edd74ff1cf2150f36ffa3b0dae40b17f-refs/branch-heads/5060@{#853})","userDataDir":"/var/folders/yr/j58lybtd30qfqw4j91dq_zs00000gq/T/.com.google.Chrome.CbSull"},"goog:chromeOptions":{"debuggerAddress":"localhost:61010"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true},"config":{"specs":["./test/specs/**/*.ts"],"suites":{},"exclude":[],"logLevel":"info","logLevels":{},"excludeDriverLogs":[],"bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["html-nice",{"outputDir":"./reports/html-reports","filename":"report.html","reportTitle":"Test Report Title","LinkScreenshots":true,"showInBrowser":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"connectionRetryTimeout":120000,"connectionRetryCount":3,"execArgv":[],"runnerEnv":{},"runner":"local","specFileRetries":0,"specFileRetriesDelay":0,"specFileRetriesDeferred":false,"reporterSyncInterval":100,"reporterSyncTimeout":5000,"cucumberFeaturesWithLineNumbers":[],"autoCompileOpts":{"autoCompile":true,"tsNodeOpts":{"transpileOnly":true,"project":"test/tsconfig.json"},"babelOpts":{}},"mochaOpts":{"timeout":60000,"ui":"bdd"},"jasmineOpts":{"defaultTimeoutInterval":10000},"cucumberOpts":{"timeout":10000},"onPrepare":[null],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"beforeFeature":[],"beforeScenario":[],"beforeStep":[],"afterStep":[],"afterScenario":[],"afterFeature":[],"baseUrl":"http://localhost","_":["run"],"$0":"/Users/saharabureesh/Desktop/Task/node_modules/.bin/wdio","config-path":"test/wdio.conf.ts","ignoredWorkerServices":[]}},"isReactElement":false,"elementId":"30287285-1ce0-44e1-931b-9cf4be1b56db","element-6066-11e4-a52e-4f735466cecf":"30287285-1ce0-44e1-931b-9cf4be1b56db"},"x":0,"y":0},{"type":"pointerDown","button":2},{"type":"pointerUp","button":2}]}]},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"}],"retries":0,"parent":"Firs Task","state":"passed","events":[],"errorIndex":0,"end":"2022-08-02T08:29:22.758Z"},{"type":"test","start":"2022-08-02T08:29:22.761Z","_duration":3475,"uid":"test-00-2","cid":"0-0","title":"Choose the manage option and make sure the title is approptiate","fullTitle":"Firs Task.Choose the manage option and make sure the title is approptiate","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"action-manage-btn\"]"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"action-manage-btn\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e1cc26bf-1221-45b0-8223-d29de1c4a667"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e1cc26bf-1221-45b0-8223-d29de1c4a667/click","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e1cc26bf-1221-45b0-8223-d29de1c4a667/click","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"item-title\"]"},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"item-title\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9820f3d1-8078-46f2-9b00-301364b92baa"}},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9820f3d1-8078-46f2-9b00-301364b92baa","ELEMENT":"9820f3d1-8078-46f2-9b00-301364b92baa"}]},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9820f3d1-8078-46f2-9b00-301364b92baa","ELEMENT":"9820f3d1-8078-46f2-9b00-301364b92baa"}]},"result":{"value":true},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"356121b8013f09394d639e870fd49775","cid":"0-0","type":"result"}],"retries":0,"parent":"Firs Task","state":"passed","events":[],"errorIndex":0,"end":"2022-08-02T08:29:26.236Z"}],"uid":"suite-0-0","cid":"0-0","file":"/Users/saharabureesh/Desktop/Task/test/specs/tests.test.ts","title":"Firs Task","fullTitle":"Firs Task","parent":"","end":"2022-08-02T08:29:26.239Z"}],"reportFile":"/Users/saharabureesh/Desktop/Task/reports/html-reports/suite-0-0/0-0/report.html"}